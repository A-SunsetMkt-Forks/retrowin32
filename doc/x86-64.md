# retrowin32 on x86-64

This collects notes on running retrowin32 "natively" on x86-64 Rosetta on Macs.

See blog post summarizing this work:
https://neugierig.org/software/blog/2023/08/x86-x64-aarch64.html

To build, run

```
$ ./build-rosetta.sh
```

## Wine background

The main post to get things started was
[this big description of the hack](https://www.winehq.org/pipermail/wine-devel/2019-December/156602.html).

## Executable layout

Print pagezero info:

```
$ otool -l the/binary
```

Dump sections in a .rlib:

```
$ size -mlx path/to/rlib
```

## LDT

We use two LDT entries:

1. To jump between 32 and 64 bit code. A Darwin file that has some notes on
   using LDT to trampoline between 32 and 64-bit.

   https://github.com/apple/darwin-xnu/blob/main/tests/ldt.c#L73

2. The FS register used for thread local storage.
   [See a thread from the Wine author on StackOverflow](https://stackoverflow.com/questions/53244454/how-did-wine64-manage-to-handle-macos).

## Calling between x86-64 and x86

To switch the processor between x86-64 and x86 ("compatibility") mode, you
switch the CS register. There are assembly primitives "far call"/"far jmp"/"far
ret" that manage these.

- A far jmp takes an address of a "m16:32" destination:
  `segment_selector << 32 | destination_ip`.
- A far call pushes the current m16:32 and jmps.
- A far ret pops a m16:32 and jmps.

Assembly handling of these particular instructions is a bit finicky. Some tools
disassemble them as plain jmp/call/ret, and expressing the instructions is
undocumented. Using AT&T assembly syntax helped.

### WOW64 and heaven's gate

WOW64, the native Windows support for x86 in an x86-64 process, must do the same
transition. It's documented in various blog posts that refer to it as "heaven's
gate".

Here snippets of the relevant assembly follow for a 32->64-bit call, with some
annotations as to which specific call/jmp form they use. It seems this varies a
lot between Windows versions etc. and it's muddled further lots of irrelevant
details, but it's

The 32-bit function starts out:

```
part1:
mov eax, ...   # possibly an id of the desired 64-bit fn to call?
mov edx, part2
call edx   # ff d2 => ff /2 edx, near call edx
```

```
part2:
jmp [part3]  # ff 25 ...  => ff /4 disp32, near jmp disp32
```

part3 is called `Wow64Transition`` in some places. It does the actual 32->64
transition, and is code shared by all 32->64 calls.

```
part3:
jmp 0033:addr   # ea ...  =>  jmpf ptr16:32, far jmp to absolute addr
...
more x86-64 code here  # <- addr points here
presumably this forwards to the actual desired call
```

Takeaways:

1. they hard-coded the segment selector, maybe? unless they're doing some
   modification when the dll loads, but all references I see have it using 0x33.
2. they use an absolute jmp to jmp forwards by just an instruction when
   transitioning 32->64

### 64 -> 32

To start the executable, or to call a 32-bit callback from a winapi definition,
we must transition from 64-bit to 32-bit.

We start in 64-bit mode in Rust code. We don't want to touch any of the
processor state here since it is fully controlled by Rust.

We need to end up in 32-bit mode in the exe with the stack laid out as follows,
as described by stdcall:

```
return address (as pushed by call)
argument 0
argument 1
...
argument N
```

and it will clear all that from the stack when it returns with an ordinary
`ret`.

The `ljmp`/`lcall` variants that take an absolute `segment selector:address` are
not available in 64-bit mode, so we must call through the `m16:32` variants that
take a memory location.

## Trampoline assembly

We need some snippets of assembly embedded into memory at low (32-bit)
addresses.

We cannot use Rust's `asm!` related macros to generate it directly, as it
generates code at higher addresses. I tinkered a bit with trying to convice
`global_asm!` to emit a span of labels that I could then snip out at build time
but I couldn't figure it out. (We also need both 32-bit and 64-bit assembly.)

Instead, I wrote the relevant assembly by hand in some .s files, and the script
dump-asm.sh prints their source bytes such that they can be embedded by hand in
the Rust code. We need to embed some runtime values into the generated assembly
anyway.

Run it like:

```
$ ./win32/src/print-asm.sh
```

PS: I would have preferred Intel assembly, but I couldn't figure out the
instruction names for the far call/returns...

## x86-64 SDL

```
$ tar xf SDL-whatever.tar.gz
$ cd SDL-whatever
$ arch -x86_64 bash
$ ./configure --prefix=`pwd`/x86
$ make -j8 install
```

Then to build with it:

```
$ export LIBRARY_PATH=above/path/x86/lib
```
