import { hex } from './util';

/**
 * For debugging purposes we support labelling addresses.
 * These labels come either from ghidra CSV dumps, or from import tables.
 * When displaying an address we find the nearest label and display at as e.g.
 *   SomeFunction+3c
 */

/** Gathers labels into a map.  TODO: refactor how label loading works to avoid all this API. */
export class Loader {
  labels = new Map<number, string>();

  /**
   * Loads a .csv file associated with an exe path that contains labelled addresses.
   * These are generated by copy-pasting the labels from Ghidra.
   */
  async fetchCSV(path: string): Promise<void> {
    const resp = await fetch(path + '.csv');
    if (!resp.ok) return;
    const text = await resp.text();
    for (const line of text.split('\n')) {
      const [name, addr] = line.split('\t');
      this.add(parseInt(addr, 16), name);
    }
  }

  add(addr: number, name: string) {
    if (addr < 0x10000) {
      // Avoid labelling small numbers.
      return;
    }
    this.labels.set(addr, name);
  }
}

/** Manages the collection of labels, as an ordered list. */
export class Labels {
  byAddr: Array<[number, string]>;

  constructor(loader: Loader) {
    this.byAddr = Array.from(loader.labels.entries());
    this.byAddr.sort(([a, _], [b, __]) => a - b);
  }

  find(addr: number): [string, number] | undefined {
    // binary search for addr
    if (this.byAddr.length === 0) return undefined;
    let lo = 0, hi = this.byAddr.length;
    while (lo < hi - 1) {
      const mid = Math.floor((lo + hi) / 2);
      const [cur, label] = this.byAddr[mid];
      if (cur < addr) {
        lo = mid;
      } else if (cur > addr) {
        hi = mid;
      } else if (addr === cur) {
        return [label, 0];
      }
    }
    const [cur, label] = this.byAddr[lo];
    if (cur < addr) {
      // Show the offset relative to the nearest labelled entry.
      const delta = addr - cur;
      // We don't want very high addresses to appear as last+largenumber, so cap delta.
      if (delta < 0x1000) {
        return [label, delta];
      }
    }
    return undefined;
  }

  get(addr: number): string | undefined {
    const match = this.find(addr);
    if (!match) return;
    let str = match[0];
    if (match[1]) str += `+${hex(match[1], 0)}`;
    return str;
  }
}
